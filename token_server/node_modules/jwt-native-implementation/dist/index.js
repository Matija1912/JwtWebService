"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
  }
});

// src/native.ts
var require_native = __commonJS({
  "src/native.ts"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var import_path = __toESM(require("path"));
    var { hmac_sha256: hmac_sha2562, base64url_encode: base64url_encode2, base64url_decode: base64url_decode2 } = require("node-gyp-build")(import_path.default.resolve(__dirname, ".."));
    var native = {
      hmac_sha256: hmac_sha2562,
      base64url_encode: base64url_encode2,
      base64url_decode: base64url_decode2
    };
    module2.exports = native;
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  decode: () => decode,
  sign: () => sign,
  verify: () => verify
});
module.exports = __toCommonJS(index_exports);
init_cjs_shims();
var import_native = __toESM(require_native());
function decode(data) {
  return (0, import_native.base64url_decode)(Buffer.from(data), Buffer.from(data).length);
}
function sign(payload, secretOrPrivateKey, options) {
  const iat = Math.floor(Date.now() / 1e3);
  const payloadData = Buffer.from(JSON.stringify({
    ...payload,
    ...options?.noTimestamp ? {} : { iat },
    ...options?.notBefore !== void 0 ? { nbf: options.notBefore + iat } : {},
    ...options?.expiresIn !== void 0 ? { exp: options.expiresIn + iat } : {},
    ...options?.audience !== void 0 ? { aud: options.audience } : {},
    ...options?.issuer !== void 0 ? { iss: options.issuer } : {},
    ...options?.subject !== void 0 ? { sub: options.subject } : {}
  }));
  const headerData = Buffer.from(JSON.stringify({
    ...options?.algorithm !== void 0 ? { alg: options.algorithm } : { alg: "HS256" },
    ...options?.header?.typ !== void 0 ? { typ: options.header.typ } : { typ: "JWT" }
  }));
  if (options === void 0 || options.algorithm === void 0 || options.algorithm === "HS256") {
    const b64u = Buffer.from((0, import_native.base64url_encode)(headerData, headerData.length).toString() + "." + (0, import_native.base64url_encode)(payloadData, payloadData.length).toString());
    const secret = Buffer.isBuffer(secretOrPrivateKey) ? secretOrPrivateKey : Buffer.from(secretOrPrivateKey);
    const signature = (0, import_native.hmac_sha256)(b64u, b64u.length, secret, secret.length);
    return (0, import_native.base64url_encode)(headerData, headerData.length).toString() + "." + (0, import_native.base64url_encode)(payloadData, payloadData.length).toString() + "." + (0, import_native.base64url_encode)(signature, signature.length).toString();
  } else if (options.algorithm === "RS256") {
    return "Asymetric";
  }
  return "asd";
}
function verify(token, secretOrPrivateKey, options) {
  const jwt = token.split(".");
  const secret = Buffer.isBuffer(secretOrPrivateKey) ? secretOrPrivateKey : Buffer.from(secretOrPrivateKey);
  const b64u = Buffer.from(jwt[0] + "." + jwt[1]);
  const signature = (0, import_native.base64url_decode)(Buffer.from(jwt[2]), Buffer.from(jwt[2]).length);
  const checkSignature = (0, import_native.hmac_sha256)(b64u, b64u.length, secret, secret.length);
  if (checkSignature.toString("hex") === signature.toString("hex")) {
    console.log("Verified!");
    const payloadBuffer = Buffer.from(jwt[1]);
    return JSON.parse((0, import_native.base64url_decode)(payloadBuffer, payloadBuffer.length).toString());
  } else {
    console.log("Invalid!");
    console.log("Signature: " + signature.toString("hex"));
    console.log("Check Signature: " + checkSignature.toString("hex"));
  }
  return "";
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  decode,
  sign,
  verify
});
